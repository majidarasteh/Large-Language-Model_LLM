# Pretraining on Unlabeled Data
Pretraining is the foundational stage where a Large Language Model (LLM) learns the statistical patterns, grammar, facts, and reasoning abilities of a language by predicting the next word in a vast corpus of text. This process is self-supervised; the data is unlabeled because the "label" for any given word is simply the next word in the sequence.

## Test generation using GPT

Generating text with a model like GPT is a three-step cycle:  
1. **Tokenization:** The input text is converted into a sequence of token IDs using a tokenizer (e.g., GPT-2's BPE tokenizer).
2. **Model Inference:** The sequence of token IDs is fed into the LLM. The model's final output is a tensor of logits for each position in the sequence. These logits represent scores for every token in the model's vocabulary, indicating the model's prediction for the next token.
3. **Decoding:** The logits are converted back into token IDs. This can be done deterministically (e.g., always choosing the token with the highest score, "greedy decoding") or stochastically (e.g., using temperature or top-k sampling to introduce creativity). Finally, the new token IDs are converted back into human-readable text by the tokenizer.

This process is repeated autoregressively: the newly generated token is appended to the input, and the cycle continues until a stopping condition is met (e.g., a maximum length or an end-of-sequence token is generated). 

<img width="869" height="483" alt="image" src="https://github.com/user-attachments/assets/5cf810ab-8692-4108-a2cc-24cc8c270a1c" />

##  Evaluating Generative Text Models
Once text is generated, we need ways to measure its quality. Evaluating the quality of text generated by a Large Language Model (LLM) is a critical step in the development process. Basic evaluation methods include:  

1. **Loss-based Metrics (Intrinsic Evaluation):**
   * Cross-Entropy Loss / Perplexity: The most fundamental quantitative measure. It calculates how well the model's predicted probability distribution matches the actual distribution of words in a held-out test dataset.
   * Lower Perplexity indicates the model is more "confident" and accurate in its predictions. This is an automatic, inexpensive metric that is core to the training process but doesn't always perfectly correlate with human judgment of quality.
2. **Human Evaluation (Extrinsic Evaluation):** The gold standard for evaluation. Humans rate generated text based on criteria like:
   * Coherence: Does the text make sense and flow logically?
   * Fluency: Is the text grammatically correct and natural-sounding?
   * Relevance: Does the text stay on-topic and address the prompt?
   * Factual Accuracy: For non-fiction, is the information correct?
     
Evaluation involves a combination of automatic metrics (like loss) to track progress during training and human-centric methods (inspection and scoring) to ultimately assess the usefulness and quality of the generated text.

## Calculating the Text Generation Loss
The text generation loss is a numerical score that quantifies how well the model's predictions match the actual text data. The loss function provides a single, automated metric to assess the quality of the model's output during training. It is the foundation for training the model, as the goal is to minimize this loss.

Figure below outlines the text generation process using a simplified seven-token vocabulary for illustrative clarity, the actual GPTModel operates on a vastly larger scale. In practice, the model utilizes a extensive vocabulary consisting of 50,257 unique tokens. Furthermore, this figure utilizes a single text example ('every effort moves') to demonstrate the generation process in a simplified and clear manner.

<img width="860" height="527" alt="image" src="https://github.com/user-attachments/assets/537e8836-ff89-4ad0-bcb6-f0747e8019cf" />

To calculating text generation loss, first, we need example data. The input is a sequence of tokens. The target is the same sequence, but shifted one token to the left. This teaches the model to predict the next word. For example:  

**Step 1: Prepare the Batch** You have two input sequences and their corresponding target sequences (the correct next tokens).

* Input Text: "Every effort moves"
* Input Text: "I really like"
* Target Text: "effort moves you"
* Target Text: "really like chocolate:

These are converted to token IDs using the tokenizer:
* Input IDs: ```torch.tensor([16833, 3626, 6100])``` --->  (for ['Every', 'effort', 'moves'])
* Input IDs: ```torch.tensor([40, 1107, 588])```     --->  (for ['I', 'really', 'like'])
* Target IDs: ```torch.tensor([3626, 6100, 345])```  --->  (for ['effort', 'moves', 'you'])
* Target IDs: ```torch.tensor([1107, 588, 11311])``` ---> (for ['really', 'like', 'chocolate'])

These are combined into single tensors for the batch:
* ```inputs = torch.tensor([[16833, 3626, 6100], [40, 1107, 588]])```
* ```targets = torch.tensor([[3626, 6100, 345], [1107, 588, 11311]])```

You have two input sequences and their corresponding target sequences (the correct next tokens).

**Step 2: Get the Model's Predictions (Logits)** The input tensor is fed into the model. The model doesn't output text; it outputs logits (scores) for every token in its vocabulary for every position in the input.

* **Output Shape:** ```[batch_size, num_tokens, vocab_size]```
* For our batch: The output is a tensor of shape [2, 3, 50257].
  - 2 examples in the batch.
  - 3 tokens per example.
  - 50,257 scores (logits) for each token position.

**Step 3: Calculate the Loss (Cross-Entropy)** We now compare the model's predictions (logits) to the true answers (targets).
1. **Flatten the Tensors:** We reshape the tensors to treat every prediction independently.
   * Logits: Shape [2, 3, 50257] is reshaped to [6, 50257]. We now have 6 total predictions to check (3 tokens per batch × 2 batchs).
   * Targets: Shape [2, 3] is reshaped to [6]. We now have 6 correct answers.
     
2. **Apply Cross-Entropy Loss:**
   * The F.cross_entropy function does the calculation. For each of the 6 positions, it:
     - Applies softmax to the 50,257 logits to get a probability distribution.
     - Checks the probability the model assigned to the correct token (the target ID).
     - Takes the negative logarithm of that probability.
    * Example: For the first target ID $3626$ (which is "effort"), if the model's probability is low (e.g., $0.1$), the loss for that prediction is high: $-log(0.1) ≈ 2.3$. If the probability is high (e.g., $0.9$), the loss is low: $-log(0.9) ≈ 0.1$.
      
3. **Get the Final Score:**
   * The losses for all 6 individual predictions are averaged into a single number. This is the final loss value.

## Backpropagation and the Cross-Entropy Loss
The mechanism for maximizing the correct token probabilities is backpropagation. This process calculates how each model weight contributes to the final error, providing a precise roadmap for optimization.

1. **The Loss Function as a Guide:** Backpropagation requires a loss function to quantify the model's error. In this case, the error is the difference between the model's predicted probability distribution and the ideal distribution where the correct token has a probability of 1.
2. **The Manual Calculation**
   * For a given input and target, extract the model's predicted probability for the correct next token at each position (_target_probas_1_ and _target_probas_2_).
     - e.g. ```target_probas_1 = [7.4541e-05, 3.1061e-05, 1.1563e-05]```
     - e.g. ```target_probas_2 = [1.0337e-05, 5.6776e-05, 4.7559e-06]```
   *  Apply the logarithm to these probabilities. Since probabilities are $≤1$, their logarithms are $≤0$. A higher probability (e.g., $0.9$) results in a less negative log value (~-0.1) than a low probability (e.g., 0.1, which has a log of ~-2.3).
     - Resulting Log Probabilities: ```tensor([ -9.5042, -10.3796, -11.3677, -11.4798, -9.7764, -12.2561])```
     - The first three values are the log-probs for Text 1.
     - The last three values are the log-probs for Text 2.
   *  Average these log probabilities. The goal is to maximize this average, bringing it as close to 0 as possible (which corresponds to predicting the correct token with $100%$ confidence).
   * - Calculate the average log probability:
     - ```avg_log_probas = mean([ -9.5042 + -10.3796 + -11.3677 + -11.4798 + -9.7764 + -12.2561 ])```
     - ```avg_log_probas = mean([-64.7638]) ≈ -10.794```
   *  In practice, we minimize a loss function. Therefore, we take the negative average log probability, known as the **cross-entropy loss**. This transforms our goal from "maximize the average log prob" to "minimize the negative average log prob," pushing the loss value toward 0.
   * - ```neg_avg_log_probas = avg_log_probas  × -1```
     - ```neg_avg_log_probas = -10.794 × -1 = 10.794```
     - Your final loss value is 10.794.
3. **From Calculation to Optimization:** The calculated loss value is a single number representing the model's total error. Backpropagation uses calculus (the chain rule) to compute the gradient of this loss with respect to every model parameter. The optimizer then uses these gradients to update the weights, adjusting them in a way that is calculated to reduce the loss on the next iteration. This cycle of prediction, loss calculation, and weight adjustment via backpropagation is the fundamental process that trains the neural network.

### Cross-Entropy Loss for LLMs
The cross-entropy loss is the fundamental mechanism for training LLMs. It quantifies the difference between the model's predicted probability distribution and the true distribution (where the correct next token has a probability of 1).
1. **Interchangeable Terms:** In practice, **"cross-entropy loss"** and **"negative average log probability"** are synonymous for this task. Both describe the same calculation: measuring how surprised the model is by the correct answer.
   
2. **Tensor Shapes:** The operation requires aligning two tensors:
   - Logits: The model's raw predictions with shape ```[batch_size, num_tokens, vocab_size]```
   - Targets: The correct token IDs with shape ```[batch_size, num_tokens]```
     
3. **Flattening:** To compute the loss across the entire batch, these tensors are flattened. This combines all batch elements and sequence positions into one long list of individual predictions to evaluate.
   - ```logits_flat: [batch_size * num_tokens, vocab_size]``` (e.g., [6, 50257])
   - ```targets_flat: [batch_size * num_tokens]``` (e.g., [6])
     
4. **PyTorch Simplification:** Instead of manually calculating probabilities, taking logs, and averaging, PyTorch's ```F.cross_entropy(logits_flat, targets_flat)``` function performs all these steps efficiently in one go. It internally applies softmax to the logits and then computes the negative log likelihood for the target indices.
   
5. **The Result:** The output is a single, scalar loss value (e.g., 10.794). This high value indicates a poorly performing, untrained model. The goal of training is to adjust the model's weights to minimize this value, pushing it towards zero.

### Perplexity
Perplexity is an intuitive metric derived from the cross-entropy loss, used specifically to evaluate language models. It transforms the abstract loss value into a more meaningful concept: the effective number of choices the model feels it has when predicting the next token.

1. **Calculation:** Perplexity is defined as the exponential of the loss.
   * ```Perplexity = exp(Loss)```
   * In the example: ```exp(10.794) ≈ 48,726```
     
2. **Interpretation:** A lower perplexity is better. It indicates the model is more confident and accurate in its predictions.
   * **Perfect Prediction:** A loss of 0 would give a perplexity of 1 (```exp(0) = 1```). This means the model is perfectly confident and has no uncertainty about the next token (it always assigns a probability of 1.0 to the correct choice).
   * **Random Guessing:** A model that predicts uniformly at random from a vocabulary of 50,257 tokens would have a loss of ```log(50257) ≈ 10.82``` and a perplexity of 50,257. This is the worst-case baseline.

3. **Intuitive Meaning:** Your model's perplexity of ~48,726 is extremely high and very close to the random guessing baseline of 50,257. This means the model is essentially no better than random guessing. At every step, it perceives the next token as being chosen from a set of roughly 48,725 equally likely possibilities.

## The Cost of Pretraining LLMs
Pretraining large language models is an exceptionally resource-intensive endeavor, far beyond the capabilities of most individuals or organizations. Imagine you want to teach a computer to understand and write perfect English by having it read almost every book on the internet. The process of doing this is called pretraining, and it's incredibly expensive. Here’s why:
1. **The Model is Massive:** A modern LLM isn't a simple program; it's a gigantic network of billions of "parameters". For example, a **well-known model called Llama 2 has 7 billion** of these parameters. Adjusting all of them perfectly requires a mind-boggling amount of calculation.
2. **It Needs to Read Everything:** To become smart, the model must read an almost unimaginable amount of text. The Llama 2 model was trained on **2 trillion pieces of words (tokens)**. That's like reading a massive library of books millions of times over.
3. **It Requires Supercomputers, Not Just Laptops:** You can't run this on a home computer. It requires thousands of the most powerful specialized processors **(called GPUs, like NVIDIA A100s)** running non-stop for months.
   * **Time:** The Llama 2 model needed **184,320 hours** of time on these **A100 GPUs**.
   * **Cost:** Renting that kind of firepower from a **cloud provider like AWS** costs a fortune. A rough estimate for this single training run is **$690,000**.

This is why, we don't pretrain a model from scratch. Instead of attempting to pretrain a model from scratch which is a prohibitively expensive process, we focus on:
1. Working with a **small, manageable dataset** for educational purposes.
2. **Loading pretrained weights** from openly available models **like GPT-2**. This allows us to skip the incredibly costly pretraining phase and focus on understanding the architecture and learning the crucial. Therefore, we download a **model like GPT-2** that has already been pretrained by someone else (like **OpenAI**) who has already paid that huge cost. 

## Pretraining LLMs 

This section outlines the practical approach taken to make learning about LLMs manageable.
1. **Tiny Dataset for Learning:** The text uses a very small dataset (only 2733 tokens from a single short story) for a crucial reason: educational practicality. Training on a real, large-scale dataset takes weeks and immense computing power. This small dataset allows the code to run on a standard laptop in minutes, enabling you to experiment and learn the core concepts quickly.
   
2. **The Real Goal: Loading Pretrained Weights:** The point of this exercise is not to create a powerful model from this small story. The real objective is to build and understand the training process so that you can later **load powerful, pretrained weights from OpenAI's GPT-2 into your own code**. You are learning the mechanics on a small scale to apply them to a large-scale model later.
 
3. **Data Preparation:**
   * **Train/Validation Split:** Even with a small dataset, the standard steps of machine learning is to divide the entire dataset into two parts:
     - **Training Set:** The majority of the data (e.g., 90%) used to teach the model by adjusting its weights.
     - **Validation Set:** A smaller portion (e.g., 10%) held back and used to evaluate the model's performance on unseen data, helping to detect overfitting.
   * **Tokenize:** Both splits are converted from text into a sequence of numerical token IDs using the model's tokenizer (The figure below only shows this for the training set).
   * **Chunk the Sequences:** The long sequence of token IDs is cut into shorter, fixed-length chunks (e.g., a length of 6 tokens). This is because the model has a maximum context window it can process at once.
   * **Shuffle and Batch:** These short chunks are then:
     - **Shuffled:** Their order is randomized. This is a critical step to ensure the model doesn't learn the exact order of the original text and helps it generalize better.
     - **Batched:** The shuffled chunks are grouped into batches (e.g., a batch size of 2). Training on batches, rather than single chunks, makes the process more computationally efficient and stable.
       
 4. **Using Data Loaders**: We reuses the data loaders from (Section 05. Code - Tokenization-BPE algorithm) to efficiently chunk the text into batches.

**The Final Result:** As figure below, the output of this process is a data loader that provides ready-to-use batches of token IDs during training. Each batch has the shape [batch_size, context_length] (e.g., [2, 6]), which is the perfect format to feed into the model. This is a scaled-down simulation of the real training process. It's designed for learning the workflow and code, not for building a state-of-the-art chatbot, which is only possible with massive data and compute resources.

<img width="785" height="656" alt="image" src="https://github.com/user-attachments/assets/00ea22ae-452a-49cc-8c6c-67719b1931ec" />

### Preparing Data for LLM Training

This code splits the available text data into separate sets for training and validation, and then prepares them for efficient processing by the model during training.
1. **Splitting the Data:**
   * ```train_ratio = 0.90```: defines that 90% of the data will be used for training.
   * ```split_idx = int(train_ratio * len(text_data))```: calculates the index where to split the full text.
   * ```train_data = text_data[:split_idx]```: takes everything from the start up to the split index for training.
   * ```val_data = text_data[split_idx:]```: takes the remaining 10% for validation.

2. **Creating the Data Loaders:**
   * **For training (train_loader):**
``` 
train_loader = create_dataloader_v1(
    train_data,
    batch_size=2,
    max_length=GPT_CONFIG_124M['context_length'],
    stride=GPT_CONFIG_124M['context_length'],
    drop_last=True,
    shuffle=True,
    num_workers=0
)
```

   * ```shuffle=True```: The data chunks are shuffled in random order before each training epoch. This prevents the model from learning the order of the examples and helps it learn more general patterns.
   * ```drop_last=True```: If the total number of data chunks isn't divisible by the batch size, the last incomplete batch is dropped. This ensures every batch the model sees during training is the same size, which simplifies the training process.
   * ```stride=max_length```: The chunks do not overlap. This maximizes the number of independent training examples from the limited data.
     
   * **For Validation (val_loader):**
```
val_loader = create_dataloader_v1(
    val_data,
    batch_size=2,
    max_length=GPT_CONFIG_124M['context_length'],
    stride=GPT_CONFIG_124M['context_length'],
    drop_last=False,
    shuffle=False,
    num_workers=0
)
```
  * ```shuffle=False```: The data is not shuffled. Validation is an evaluation step, and the order of the data should be consistent for a fair and reproducible assessment of model performance.
  * ```drop_last=False```: We want to evaluate the model on all available validation data, even if it means having one smaller batch at the end. We are not training on this data, so batch size consistency is less critical.
  * ```stride=max_length```: Uses the same non-overlapping chunking as the training set for consistency.

3. **compute the loss**
   * **Transfer to Device**: ```input_batch = input_batch.to(device)```
     - Purpose: This moves the input data (token IDs) from the computer's main memory (CPU) to the processing unit (e.g., a GPU) where the model is located. This is necessary for efficient computation.
   * **Model Forward Pass**: ```logits = model(input_batch)```
     - Purpose: This runs the batch of data through the model. The model's output is a tensor of logits.
   * **Calculate Cross-Entropy Loss**: ```loss = torch.nn.functional.cross_entropy(...)```
     - This is the key step. The function calculates the difference between the model's predictions and the true targets.
   * **Flattening**: The logits tensor has a shape of ```[batch_size, seq_length, vocab_size])```. The target_batch has a shape of ```[batch_size, seq_length])```. The ```.flatten(0, 1))``` operation is used to combine the batch and sequence dimensions, reshaping the tensors to:
     - ```logits_flattened: [batch_size * seq_length, vocab_size]```
     - ```targets_flattened: [batch_size * seq_length]```
     - By the flattening the loss function then computes the average error across all of them, giving a single score for the entire batch.
   * **Return the Loss**: ```return loss```

### The LLM Training Workflow
The training process follows a structured, iterative loop designed to gradually improve the model's performance. The core steps are:
1. **Iterate Over Epochs**: An epoch represents one full pass through the entire training dataset. The model will go through the data for multiple epochs (e.g., 10 times) to learn effectively.
2. **Process Batches**: Within each epoch, the data is processed in smaller subsets called batches. This is more computationally efficient than processing the entire dataset at once.
3. **Reset Gradients**: Before processing each new batch, the optimizer's gradients are set to zero (```optimizer.zero_grad()```). This is crucial to prevent gradients from accumulating across multiple batches.
4. **Forward Pass & Calculate Loss**: The current batch of data is fed through the model (forward pass). The model's predictions are compared to the true targets using a loss function (e.g., cross-entropy) to compute a single error value.
5. **Backward Pass (Calculate Gradients)**: The ```loss.backward()``` command performs backpropagation. It calculates the gradient of the loss function with respect to every single model parameter. These gradients indicate the direction and amount each weight needs to be adjusted to reduce the error.
6. **Update Weights**: The optimizer (e.g., AdamW) takes a step (```optimizer.step()```), using the calculated gradients to update all the model's weights. This is the step that actually makes the model "learn."
   - **AdamW** is a variant of Adam that improves the weight decay approach, which aims to minimize model complexity and prevent overfitting by penalizing larger weights. This adjustment allows AdamW to achieve more effective regularization and better generalization; thus, AdamW is frequently used in the training of LLMs.
8. **Monitoring (Logging & Sampling)**: Periodically, progress is monitored. This includes:
   * **Printing Losses**: Tracking the training and validation loss to ensure the model is learning and not overfitting.
   * **Generating Text Samples**: Using the current model to generate text from a fixed prompt. This provides a qualitative, human-readable measure of improvement that goes beyond the raw loss number.

As the following figure, this cycle repeats for every batch in every epoch until training is complete. The model's weights are iteratively refined with each step, steadily improving its ability to predict the next token and generate coherent text.

<img width="522" height="598" alt="image" src="https://github.com/user-attachments/assets/881cb81a-1809-4439-99e1-6bb9942eceae" />

## Overfitting on a Small Dataset
The phenomenon where the model **memorizes passages** from the training text is a classic example of **overfitting**. So, why this happens:
1. **Extremely Small Dataset**: The model is trained on a single short story (only 2177 tokens). This is a tiny amount of data for a model with over 100 million parameters.
2. **Multiple Epochs**: The model sees this very limited dataset multiple times (for multiple epochs). With so few examples to learn from, it eventually starts to memorize the training sequences verbatim instead of learning generalizable patterns of language.

Figure below shows an example of overfitting:

<img width="597" height="428" alt="image" src="https://github.com/user-attachments/assets/f48b6abb-22e0-4f62-99cd-c351e761e3c3" />

In real-world LLM training, the opposite approach is used:

1. **Massive Datasets**: Models are trained on enormous, internet-scale corpora (trillions of tokens).
2. **Few Epochs**: They are typically trained for only one epoch (a single pass through the entire dataset). The dataset is so vast and diverse that the model cannot memorize it and is forced to learn general patterns.

**The Project Gutenberg:** The note suggests that if you were to use a much larger dataset—like 60,000 books from Project Gutenberg, the model would have enough diverse examples to learn the underlying structure of the language (grammar, syntax, common phrases) rather than just memorizing the text. This would result in a model that can generate original, coherent text instead of reproducing memorized passages.

## Decoding Strategies
Text generation strategies, or decoding strategies, are techniques used to control the randomness and creativity of an LLM's output. The default method, greedy decoding (always choosing the most likely next word), is deterministic and often produces repetitive and uncreative text. Two different approaches are as follow:
1. **Greedy Decoding (Baseline)**: The simplest method, which always selects the token with the highest probability (using ```argmax```). This often leads to repetitive and predictable text.
2. **Probabilistic Sampling**: Instead of always taking the top token, sample from the probability distribution using ```multinomial```. This introduces variety, as less likely tokens can occasionally be chosen. For example:
   * The word "forward" might be chosen 58.2% of the time.
   * Other words like "toward" (34.3%) or "closer" (7.3%) are sometimes selected.

### Temperature Scaling
Temperature scaling is a technique used to control the randomness and creativity of text generated by large language models (LLMs). It adjusts the probability distribution of the next token before sampling, influencing the model's output diversity. Temperature Scaling adjusts the logits (raw scores) by dividing them by a temperature parameter before applying softmax. Effect of Different Temperatures
1. **emperature = 1**: This is the baseline. The model's original probabilities are used, and sampling provides a natural level of variety.
2. **Low Temperature (e.g., T < 1)**: Makes the probability distribution "sharper" or "peakier." The model becomes more confident in its top choices, making outputs more deterministic and focused. It behaves more like greedy decoding, choosing the most likely words.
3. **High Temperature (e.g., T > 1)**: Makes the distribution "flatter" or more uniform. The model becomes less confident, giving a higher chance to unlikely words. This increases creativity and diversity but also the risk of generating nonsense or grammatical errors (e.g., "every effort moves you pizza").

In essence, temperature is a dial for controlling creativity. By adjusting the temperature, users can balance between coherence and novelty in generated text. This makes temperature a critical hyperparameter for controlling LLM behavior in practical applications. 

* **Low Temperature**: Best for tasks requiring accuracy and consistency (e.g., code generation, factual responses). Low $T$ is safe, predictable, but potentially boring.
* **High Temperature**: Useful for creative applications (e.g., storytelling, brainstorming). High $T$ is creative, surprising, but potentially incoherent.  

**For example:**  

<img width="730" height="494" alt="image" src="https://github.com/user-attachments/assets/6fa4462b-af7e-44c8-a126-776ea70da985" />















